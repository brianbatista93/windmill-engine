#include <yaml-cpp/yaml.h>

#include "BailiffProject.hpp"
#include "Encoding/AnsiEncoder.hpp"
#include "Exceptions/BailiffException.hpp"
#include "HAL/File.hpp"
#include "HAL/FileSystem.hpp"
#include "Logging/Log.hpp"

DECLARE_STATIC_LOG_EMITTER(Bailiff, eAll);

CMap<CString, CString> CBailiffProject::kProjectVariables;

u32 CBailiffProject::kProjectFileVersion = 1;

void CBailiffProject::Create(tchar *ppArgs[], i32 nArgC)
{
    if (nArgC == 2 or *ppArgs[1] == 0)
    {
        throw CBailiffException(WT("No project name specified"));
    }

    const auto projectName = CString{ppArgs[2]};
    const auto workingDir = CPaths::GetWorkingDirectory();
    const auto projectDir = workingDir / ppArgs[2];

    kProjectVariables.Add(WTL("${PROJECT_NAME}"), projectName);
    kProjectVariables.Add(WTL("${PROJECT_DIR}"), projectDir.ToString());

    if (CFileSystem::DirectoryExists(projectDir))
    {
        throw CBailiffException(WT("Project '{0}' directory already exists"), *projectName);
    }

    WE_VERB(Bailiff, WT("Creating directory: '{0}'"), *projectDir);
    if (!CFileSystem::CreateDirectory(projectDir))
    {
        throw CBailiffException(WT("Could not create project's directory"));
    }

    for (i32 i = 0; i < GetArrayCount(kProjectDirectories); ++i)
    {
        const auto subDir = projectDir / ExpandString(kProjectDirectories[i]);
        WE_VERB(Bailiff, WT("Creating directory: '{0}'"), *subDir);
        if (!CFileSystem::CreateDirectory(subDir))
        {
            throw CBailiffException(WT("Could not create sub-directory: '{0}'"), *subDir);
        }
    }

    if (!CreateGitIgnoreFile(projectDir))
    {
        throw CBailiffException(WT("Could not create .gitignore file"));
    }

    if (!CreateProjectFile(projectDir, projectName))
    {
        throw CBailiffException(WT("Could not create project file"));
    }
}

bool CBailiffProject::CreateProjectFile(const CPath &projectDir, const CString &projectName)
{
    return CFile::WriteString(projectName, projectDir / kProjectFilename);
}

bool CBailiffProject::CreateGitIgnoreFile(const CPath &projectDir)
{
    CStringBuilder builder;
    builder.AppendLine(WTL("# Visual Studio 2015 user specific files"));
    builder.AppendLine(WTL(".vs/"));
    builder.AppendLine(CString::kEmpty);

    builder.AppendLine(WTL("# Binary Files"));
    builder.AppendLine(WTL("Binaries/*"));
    builder.AppendLine(CString::kEmpty);

    builder.AppendLine(WTL("# Intermediate Files"));
    builder.AppendLine(WTL("Intermediate/*"));
    builder.AppendLine(CString::kEmpty);

    builder.AppendLine(WTL("# Configuration files generated by the engine"));
    builder.AppendLine(WTL("MetaFiles/*"));
    builder.AppendLine(CString::kEmpty);

    return CFile::WriteString(builder.ToString(), projectDir / WT(".gitignore"), CFile::EEncoding::eUTF8);
}

CString CBailiffProject::ExpandString(const tchar *pStr)
{
    const i32 varBegin = CStringUtils::Find(pStr, WT("${"));
    if (varBegin == -1)
    {
        return pStr;
    }

    const i32 varEnd = CStringUtils::Find(pStr, WT('}'), varBegin);
    if (varEnd == -1)
    {
        return pStr;
    }

    CString varName = CString{pStr}.Substring(varBegin, varEnd - varBegin + 1);
    const auto varValue = kProjectVariables.Find(varName);
    if (varValue == nullptr)
    {
        return pStr;
    }

    return CString{pStr}.Replace(varBegin, varEnd + 1, *varValue);
}

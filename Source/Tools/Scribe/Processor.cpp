#include "Attributes.hpp"
#include "HAL/File.hpp"
#include "HAL/FileSystem.hpp"
#include "Logging/Log.hpp"

DECLARE_STATIC_LOG_EMITTER(Scribe, eInfo);

bool Parse(const CString &content, CStringBuilder &builder);

CStringBuilder WriteHeaderAndGetStringBuilder();

tchar *IgnoreWhiteSpace(const tchar *, i32 &);
tchar *IgnoreComments(const tchar *, i32 &);
tchar *ParseDeep(const tchar *, CStringBuilder &, i32 &);
tchar *IdentifyAttribute(const tchar *, CStringBuilder &, i32 &);
tchar *ProcessAttribute(const tchar *, CStringBuilder &, i32 &);

CString GetAttributeName(const tchar *);

bool ProcessFile(const CPath &filePath)
{
    static CPath generatedDirectory = WTL("Generated");

    if (!CFileSystem::DirectoryExists(generatedDirectory))
    {
        if (!CFileSystem::CreateDirectory(generatedDirectory))
        {
            return false;
        }
    }

    CString fileContent;
    if (!CFile::ReadString(fileContent, filePath))
    {
        WE_ERROR(Scribe, WT("Failed to read file {0}"), *filePath);
        return false;
    }

    CStringBuilder builder = WriteHeaderAndGetStringBuilder();

    if (!Parse(fileContent, builder))
    {
        WE_ERROR(Scribe, WT("Failed to parse file {0}"), *filePath);
        return false;
    }

    if (!CFile::WriteString(builder.ToString(), generatedDirectory / filePath.GetFileNameWithoutExtension() + WT(".gen.hpp")))
    {
        WE_ERROR(Scribe, WT("Failed to write file {0}"), *filePath);
        return false;
    }

    return true;
}

bool Parse(const CString &content, CStringBuilder &builder)
{
    if (content.IsEmpty())
    {
        return true;
    }

    i32 line = 1;
    tchar *pPointer = (tchar *)*content;
    pPointer = IgnoreWhiteSpace(pPointer, line);

    return ParseDeep(pPointer, builder, line);
}

CStringBuilder WriteHeaderAndGetStringBuilder()
{
    CStringBuilder builder(1024);

    builder.AppendLine(WTL("/*"));
    builder.AppendLine(WTL("This file was generated by Scribe. Don't modify it."));
    builder.AppendLine(WTL("*/"));
    builder.AppendLine(WTL(""));
    builder.AppendLine(WTL("#pragma once"));

    return builder;
}

tchar *IgnoreWhiteSpace(const tchar *pStr, i32 &rLine)
{
    we_assert(pStr);

    while (isspace(*pStr))
    {
        if (*pStr == WT('\n'))
        {
            ++rLine;
        }
        ++pStr;
    }

    we_assert(pStr);
    return (tchar *)pStr;
}

tchar *IgnoreComments(const tchar *pStr, i32 &rLine)
{
    we_assert(pStr and *pStr);

    while (*pStr)
    {
        if (*pStr == WT('/'))
        {
            if (*(pStr + 1) == WT('/'))
            {
                while (*pStr != WT('\n'))
                {
                    ++pStr;
                }
                ++rLine;
                ++pStr;
            }
            else if (*(pStr + 1) == WT('*'))
            {
                while (*pStr != WT('*') or *(pStr + 1) != WT('/'))
                {
                    if (*pStr == WT('\n'))
                    {
                        ++rLine;
                    }
                    ++pStr;
                }
                pStr += 2;
            }
            else
            {
                break;
            }
        }
        else
        {
            break;
        }
    }

    return (tchar *)pStr;
}

tchar *ParseDeep(const tchar *pStr, CStringBuilder &builder, i32 &rLine)
{
    while (pStr and *pStr)
    {
        pStr = IdentifyAttribute(pStr, builder, rLine);
    }

    return (tchar *)pStr;
}

tchar *IdentifyAttribute(const tchar *pStr, CStringBuilder &builder, i32 &rLine)
{
    we_assert(pStr and *pStr);

    pStr = IgnoreWhiteSpace(pStr, rLine);
    pStr = IgnoreComments(pStr, rLine);

    static const tchar *sAttrBegin = {WT("[[WE::")};
    static const tchar *sAttrEnd = {WT("]]")};

    static i32 sAttrBeginLength = 6;
    static i32 sAttrEndLength = 2;

    while (*pStr)
    {
        if (CStringUtils::Equal(pStr, sAttrBegin, sAttrBeginLength))
        {
            pStr += sAttrBeginLength;
            pStr = ProcessAttribute(pStr, builder, rLine);
        }
        else if (*pStr == WT('\n'))
        {
            ++pStr;
            ++rLine;
        }
        else
        {
            ++pStr;
        }
    }

    return (tchar *)pStr;
}

tchar *ProcessAttribute(const tchar *pStr, CStringBuilder &builder, i32 &rLine)
{
    CString attributeName = GetAttributeName(pStr);
    if (auto it = gAttributeFunctions.find(*attributeName); it != gAttributeFunctions.end())
    {
        return it->second(pStr, builder, rLine);
    }
    else
    {
        // TODO: Fix the attribute name
        WE_ERROR(Scribe, WT("Could not find attribute: {0}"), *attributeName);
        return nullptr;
    }
}

CString GetAttributeName(const tchar *pStr)
{
    const tchar *start = pStr;

    while (*pStr and isalpha(*pStr))
        ++pStr;

    return CString(start, (pStr - start));
}